{
  "version": 3,
  "sources": ["../../three/examples/jsm/modifiers/CurveModifier.js"],
  "sourcesContent": ["// Original src: https://github.com/zz85/threejs-path-flow\nconst CHANNELS = 4;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\n\nimport {\n\tDataTexture,\n\tRGBAFormat,\n\tFloatType,\n\tRepeatWrapping,\n\tMesh,\n\tInstancedMesh,\n\tNearestFilter,\n\tDynamicDrawUsage,\n\tMatrix4\n} from 'three';\n\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\n */\nexport function initSplineTexture( numberOfCurves = 1 ) {\n\n\tconst dataArray = new Float32Array( TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS );\n\tconst dataTexture = new DataTexture(\n\t\tdataArray,\n\t\tTEXTURE_WIDTH,\n\t\tTEXTURE_HEIGHT * numberOfCurves,\n\t\tRGBAFormat,\n\t\tFloatType\n\t);\n\n\tdataTexture.wrapS = RepeatWrapping;\n\tdataTexture.wrapY = RepeatWrapping;\n\tdataTexture.magFilter = NearestFilter;\n\tdataTexture.needsUpdate = true;\n\n\treturn dataTexture;\n\n}\n\n/**\n * Write the curve description to the data texture\n *\n * @param { DataTexture } texture The DataTexture to write to\n * @param { Curve } splineCurve The curve to describe\n * @param { number } offset Which curve slot to write to\n */\nexport function updateSplineTexture( texture, splineCurve, offset = 0 ) {\n\n\tconst numberOfPoints = Math.floor( TEXTURE_WIDTH * ( TEXTURE_HEIGHT / 4 ) );\n\tsplineCurve.arcLengthDivisions = numberOfPoints / 2;\n\tsplineCurve.updateArcLengths();\n\tconst points = splineCurve.getSpacedPoints( numberOfPoints );\n\tconst frenetFrames = splineCurve.computeFrenetFrames( numberOfPoints, true );\n\n\tfor ( let i = 0; i < numberOfPoints; i ++ ) {\n\n\t\tconst rowOffset = Math.floor( i / TEXTURE_WIDTH );\n\t\tconst rowIndex = i % TEXTURE_WIDTH;\n\n\t\tlet pt = points[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.tangents[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.normals[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.binormals[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\n\t}\n\n\ttexture.needsUpdate = true;\n\n}\n\n\nfunction setTextureValue( texture, index, x, y, z, o ) {\n\n\tconst image = texture.image;\n\tconst { data } = image;\n\tconst i = CHANNELS * TEXTURE_WIDTH * o; // Row Offset\n\tdata[ index * CHANNELS + i + 0 ] = x;\n\tdata[ index * CHANNELS + i + 1 ] = y;\n\tdata[ index * CHANNELS + i + 2 ] = z;\n\tdata[ index * CHANNELS + i + 3 ] = 1;\n\n}\n\n/**\n * Create a new set of uniforms for describing the curve modifier\n *\n * @param { DataTexture } Texture which holds the curve description\n */\nexport function getUniforms( splineTexture ) {\n\n\tconst uniforms = {\n\t\tspineTexture: { value: splineTexture },\n\t\tpathOffset: { type: 'f', value: 0 }, // time of path curve\n\t\tpathSegment: { type: 'f', value: 1 }, // fractional length of path\n\t\tspineOffset: { type: 'f', value: 161 },\n\t\tspineLength: { type: 'f', value: 400 },\n\t\tflow: { type: 'i', value: 1 },\n\t};\n\treturn uniforms;\n\n}\n\nexport function modifyShader( material, uniforms, numberOfCurves = 1 ) {\n\n\tif ( material.__ok ) return;\n\tmaterial.__ok = true;\n\n\tmaterial.onBeforeCompile = ( shader ) => {\n\n\t\tif ( shader.__modified ) return;\n\t\tshader.__modified = true;\n\n\t\tObject.assign( shader.uniforms, uniforms );\n\n\t\tconst vertexShader = `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t`\n\t\t// chunk import moved in front of modified shader below\n\t\t\t.replace( '#include <beginnormal_vertex>', '' )\n\n\t\t\t// vec3 transformedNormal declaration overriden below\n\t\t\t.replace( '#include <defaultnormal_vertex>', '' )\n\n\t\t\t// vec3 transformed declaration overriden below\n\t\t\t.replace( '#include <begin_vertex>', '' )\n\n\t\t\t// shader override\n\t\t\t.replace(\n\t\t\t\t/void\\s*main\\s*\\(\\)\\s*\\{/,\n\t\t\t\t`\nvoid main() {\n#include <beginnormal_vertex>\n\nvec4 worldPos = modelMatrix * vec4(position, 1.);\n\nbool bend = flow > 0;\nfloat xWeight = bend ? 0. : 1.;\n\n#ifdef USE_INSTANCING\nfloat pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\nfloat spineLengthFromInstanceMatrix = instanceMatrix[3][0];\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n#else\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n#endif\n\nmt = mod(mt, textureStacks);\nfloat rowOffset = floor(mt);\n\n#ifdef USE_INSTANCING\nrowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n#endif\n\nvec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\nmat3 basis = mat3(a, b, c);\n\nvec3 transformed = basis\n\t* vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n\t+ spinePos;\n\nvec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t` ).replace(\n\t\t\t\t'#include <project_vertex>',\n\t\t\t\t`vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`\n\t\t\t);\n\n\t\tshader.vertexShader = vertexShader;\n\n\t};\n\n}\n\n/**\n * A helper class for making meshes bend aroudn curves\n */\nexport class Flow {\n\n\t/**\n\t * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n\t * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n\t */\n\tconstructor( mesh, numberOfCurves = 1 ) {\n\n\t\tconst obj3D = mesh.clone();\n\t\tconst splineTexure = initSplineTexture( numberOfCurves );\n\t\tconst uniforms = getUniforms( splineTexure );\n\t\tobj3D.traverse( function ( child ) {\n\n\t\t\tif (\n\t\t\t\tchild instanceof Mesh ||\n\t\t\t\tchild instanceof InstancedMesh\n\t\t\t) {\n\n\t\t\t\tchild.material = child.material.clone();\n\t\t\t\tmodifyShader( child.material, uniforms, numberOfCurves );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.curveArray = new Array( numberOfCurves );\n\t\tthis.curveLengthArray = new Array( numberOfCurves );\n\n\t\tthis.object3D = obj3D;\n\t\tthis.splineTexure = splineTexure;\n\t\tthis.uniforms = uniforms;\n\n\t}\n\n\tupdateCurve( index, curve ) {\n\n\t\tif ( index >= this.curveArray.length ) throw Error( 'Index out of range for Flow' );\n\t\tconst curveLength = curve.getLength();\n\t\tthis.uniforms.spineLength.value = curveLength;\n\t\tthis.curveLengthArray[ index ] = curveLength;\n\t\tthis.curveArray[ index ] = curve;\n\t\tupdateSplineTexture( this.splineTexure, curve, index );\n\n\t}\n\n\tmoveAlongCurve( amount ) {\n\n\t\tthis.uniforms.pathOffset.value += amount;\n\n\t}\n\n}\nconst matrix = new Matrix4();\n\n/**\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\n */\nexport class InstancedFlow extends Flow {\n\n\t/**\n\t *\n\t * @param {number} count The number of instanced elements\n\t * @param {number} curveCount The number of curves to preallocate for\n\t * @param {Geometry} geometry The geometry to use for the instanced mesh\n\t * @param {Material} material The material to use for the instanced mesh\n\t */\n\tconstructor( count, curveCount, geometry, material ) {\n\n\t\tconst mesh = new InstancedMesh(\n\t\t\tgeometry,\n\t\t\tmaterial,\n\t\t\tcount\n\t\t);\n\t\tmesh.instanceMatrix.setUsage( DynamicDrawUsage );\n\t\tmesh.frustumCulled = false;\n\t\tsuper( mesh, curveCount );\n\n\t\tthis.offsets = new Array( count ).fill( 0 );\n\t\tthis.whichCurve = new Array( count ).fill( 0 );\n\n\t}\n\n\t/**\n\t * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n\t * This writes that information to the matrix and marks it as needing update.\n\t *\n\t * @param {number} index of the instanced element to update\n\t */\n\twriteChanges( index ) {\n\n\t\tmatrix.makeTranslation(\n\t\t\tthis.curveLengthArray[ this.whichCurve[ index ] ],\n\t\t\tthis.whichCurve[ index ],\n\t\t\tthis.offsets[ index ]\n\t\t);\n\t\tthis.object3D.setMatrixAt( index, matrix );\n\t\tthis.object3D.instanceMatrix.needsUpdate = true;\n\n\t}\n\n\t/**\n\t * Move an individual element along the curve by a specific amount\n\t *\n\t * @param {number} index Which element to update\n\t * @param {number} offset Move by how much\n\t */\n\tmoveIndividualAlongCurve( index, offset ) {\n\n\t\tthis.offsets[ index ] += offset;\n\t\tthis.writeChanges( index );\n\n\t}\n\n\t/**\n\t * Select which curve to use for an element\n\t *\n\t * @param {number} index the index of the instanced element to update\n\t * @param {number} curveNo the index of the curve it should use\n\t */\n\tsetCurve( index, curveNo ) {\n\n\t\tif ( isNaN( curveNo ) ) throw Error( 'curve index being set is Not a Number (NaN)' );\n\t\tthis.whichCurve[ index ] = curveNo;\n\t\tthis.writeChanges( index );\n\n\t}\n\n}\n"],
  "mappings": "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",
  "names": []
}
